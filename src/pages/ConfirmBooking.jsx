import React, { useState, useEffect } from 'react'
import { useLocation, useNavigate, Link } from 'react-router-dom'
import { useUser } from '../contexts/UserContext'

const ConfirmBooking = () => {
  const {state} = useLocation()
  const {eventId, eventName, selectedPackages} = state;
  const { user } = useUser()
  const location = useLocation()
  const navigate = useNavigate()
  const [error, setError] = useState('')
  const [billingSameAsDelivery, setBillingSameAsDelivery] = useState(true)
  const [tokenExpired, setTokenExpired] = useState(false)
  const [tockenChecked, setTockenChecked] = useState(false)
  const [profileFormData, setProfileFormData] = useState({
    firstName: '',
    lastName: '',
    email: user.email || '',
    streetName: '',
    streetNumber: '',
    postalCode: '',
    city: user.city || '',
    country: '',
    billingStreetName: '',
    billingStreetNumber: '',
    billingPostalCode: '',
    billingCity: '',
    billingCountry: ''
  })

  // check if token is expired + get and set profile information
  useEffect(() => {
    const expiresAt = localStorage.getItem("expiresAt")
    if (!expiresAt) {
      setTokenExpired(true)
      setTockenChecked(true)
      return
    }
    const expiryTime = new Date(expiresAt)
    const isExpired = Date.now() > expiryTime.getTime()
    setTokenExpired(isExpired)
    setTockenChecked(true)

    if (!isExpired && user?.userId) {
      getProfileInfo()
    }
  }, [location.pathname, user.userId])

  
  const getProfileInfo = async () => {
    const accountProfileBaseUrl = import.meta.env.VITE_ACCOUNTPROFILESERVICE_BASEURL;
    try {
      const res = await fetch(`${accountProfileBaseUrl}/api/accountprofiles/${user.userId}`)
      if (!res.ok) return

      const data = await res.json()
      setProfileFormData(prev => ({...prev, 
        firstName: data.firstName,
        lastName: data.lastName,
        streetName: data.addressInfos[0]?.streetName || '',
        streetNumber: data.addressInfos[0]?.streetNumber || '',
        postalCode: data.addressInfos[0]?.postalCode || '',
        city: data.addressInfos[0]?.city || '',
        country: data.addressInfos[0]?.country || '',
        billingStreetName: data.addressInfos[0]?.streetName || '',
        billingStreetNumber: data.addressInfos[0]?.streetNumber || '',
        billingPostalCode: data.addressInfos[0]?.postalCode || '',
        billingCity: data.addressInfos[0]?.city || '',
        billingCountry: data.addressInfos[0]?.country || ''
      }))
    } catch(err) {
      console.log("Error loading profile", err)
    }
  }


  const updatedProfileFormData = {
    userId: user.userId,
    firstName: profileFormData.firstName,
    lastName: profileFormData.lastName,
    contactInfoModels: [
      { contactTypeId: 1, value: profileFormData.email }
    ],
    addressInfoModels: [
      { addressTypeId: 1, streetName: profileFormData.streetName, streetNumber: profileFormData.streetNumber, postalCode: profileFormData.postalCode, city: profileFormData.city, country: profileFormData.country},
      { addressTypeId: 2, streetName: profileFormData.billingStreetName, streetNumber: profileFormData.billingStreetNumber, postalCode: profileFormData.billingPostalCode, city: profileFormData.billingCity, country: profileFormData.billingCountry},
  ]}
  
  //a part of the code in bookingFormData is generated by chatGPT
  const bookingFormData = {
    customerId: user.userId,
    eventId: eventId,
    eventName: eventName,
    invoice: {
      amount: selectedPackages.reduce((total, pkg) => total + (pkg.price * pkg.quantity), 0) + 5
    },
    tickets: selectedPackages.flatMap(pkg => 
      Array.from({ length: pkg.quantity }, () => ({
        holderFirstName: profileFormData.firstName,
        holderLastName: profileFormData.lastName,
        quantity: 1,
        type: pkg.packageType,
        price: pkg.price
      }))
    )
  }

  const copyDeliveryAddress = () => {
    setProfileFormData(prev => ({
      ...prev,
      billingStreetName: prev.streetName,
      billingStreetNumber: prev.streetNumber,
      billingPostalCode: prev.postalCode,
      billingCity: prev.city,
      billingCountry: prev.country
    }))
  }
  
  const handleChange = (e) => {
    const { name, value } = e.target

    setProfileFormData(prev => {
      const updated = {...prev, [name]: value }

      if (billingSameAsDelivery) {
        switch (name) {
          case 'streetName':
            updated.billingStreetName = value
            break;

          case 'streetNumber':
            updated.billingStreetNumber = value
            break;

          case 'postalCode':
            updated.billingPostalCode = value
            break;

          case 'city':
            updated.billingCity = value
            break;

          case 'country':
            updated.billingCountry = value
            break;

          default:
            break;
        }
      }
      return updated;
    })
  }

  const handleSubmit = async (e) => {
    e.preventDefault()
    setError('')

    try {
      const token = localStorage.getItem("token")
      const bookingBaseUrl = import.meta.env.VITE_BOOKINGSERVICE_BASEURL;
      const bookingRes = await fetch(`${bookingBaseUrl}/api/bookings/create`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
         },
        body: JSON.stringify(bookingFormData)
      })

      const accountProfileBaseUrl = import.meta.env.VITE_ACCOUNTPROFILESERVICE_BASEURL;
      const profileRes = await fetch(`${accountProfileBaseUrl}/api/accountprofiles/update`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json' },
        body: JSON.stringify(updatedProfileFormData)
      })

      if (!bookingRes.ok || !profileRes.ok) {
        setError('Booking failed.')
      } else {
        navigate("/bookingConfirmation")
      }
    } catch (error) {
      console.error("Error submitting form", error.message)
    }
  }

  if (!tockenChecked) {
    return <p>Loading...</p>
  }
  if (tokenExpired || !user?.userId) {
    return <p>You need to sign in to be able to book an event.<Link to="/login"> Sign in here.</Link></p>
  }

  return (
    <div className='wrapper'>

      {state && (
        <>
          <h2 className='center'>Confirm your booking to <strong>{eventName}</strong></h2>
          <form onSubmit={handleSubmit}>

          <div className='confirm-booking-table'>
            <table>
              <thead>
                <tr>
                  <th>Package</th>
                  <th>Quantity</th>
                  <th>Price</th>
                </tr>
              </thead>
              <tbody>
                {selectedPackages.map((pkg, index) => (
                  <tr key={index}>
                    <td>{pkg.packageType}</td>
                    <td>{pkg.quantity}</td>
                    <td>${pkg.price}</td>
                  </tr>
                ))}
                <tr>
                  <td>Fee</td>
                  <td></td>
                  <td>$5</td>
                </tr>
                <tr>
                  <td><strong>Total Price</strong></td>
                  <td></td>
                  <td><strong>${selectedPackages.reduce((total, pkg) => total + (pkg.price * pkg.quantity), 0) + 5}</strong></td>
                </tr>
              </tbody>
            </table>
          </div>
            <div>
              <div>
                <label>First name</label>
                <input className='form-input' type='text' name='firstName' value={profileFormData.firstName} onChange={handleChange} required></input>
              </div>
              <div>
                <label>Last name</label>
                <input className='form-input' type='text' name='lastName' value={profileFormData.lastName} onChange={handleChange} required></input>
              </div>
              <div>
                <label>Email address</label>
                <input className='form-input' type='email' name='email' value={profileFormData.email} onChange={handleChange} required></input>
              </div>

              <h4>Delivery Address</h4>
              <div>
                <label>Street name</label>
                <input className='form-input' type='text' name='streetName' value={profileFormData.streetName} onChange={handleChange} required></input>
              </div>
              <div>
              <div>
                <label>Street number</label>
                <input className='form-input' type='text' name='streetNumber' value={profileFormData.streetNumber} onChange={handleChange} required></input>
              </div>
              <div></div>
                <label>Postal code</label>
                <input className='form-input' type='text' name='postalCode' value={profileFormData.postalCode} onChange={handleChange} required></input>
              </div>
              <div>
                <label>City</label>
                <input className='form-input' type='text' name='city' value={profileFormData.city} onChange={handleChange} required></input>
              </div>
              <div>
                <label>Country</label>
                <input className='form-input' type='text' name='country' value={profileFormData.country} onChange={handleChange} required></input>
              </div>
            </div>

            <div className='flex'>
              <input type='checkbox' id='billing-address' checked={billingSameAsDelivery} onChange={(e) => { setBillingSameAsDelivery(e.target.checked); if (e.target.checked) {copyDeliveryAddress()}}}/>
              <label htmlFor='billing-address'>Billing address is the same as delivery address</label>
            </div>

            {!billingSameAsDelivery && (
              <div>
                <h4>Billing Address</h4>
                <div>
                  <label>Street name</label>
                  <input className='form-input' type='text' name='billingStreetName' value={profileFormData.billingStreetName} onChange={handleChange} required></input>
                </div>
                <div>
                <div>
                  <label>Street number</label>
                  <input className='form-input' type='text' name='billingStreetNumber' value={profileFormData.billingStreetNumber} onChange={handleChange} required></input>
                </div>
                <div></div>
                  <label>Postal code</label>
                  <input className='form-input' type='text' name='billingPostalCode' value={profileFormData.billingPostalCode} onChange={handleChange} required></input>
                </div>
                <div>
                  <label>City</label>
                  <input className='form-input' type='text' name='billingCity' value={profileFormData.billingCity} onChange={handleChange} required></input>
                </div>
                <div>
                  <label>Country</label>
                  <input className='form-input' type='text' name='billingCountry' value={profileFormData.billingCountry} onChange={handleChange} required></input>
                </div>
              </div>
            )}

            <div>
              <input type='checkbox' id='acceptTerms' required/>
              <label htmlFor='acceptTerms'>I accept the <a target='_blank' href='/events/:id' rel='noopener noreferrer'>Terms & Conditions</a></label>
            </div>

            {error && <p>{error}</p>}

            <button type='submit' className='btn-primary'>Book Event</button>
          </form>
        </>
      )}
    </div>
  )
}

export default ConfirmBooking